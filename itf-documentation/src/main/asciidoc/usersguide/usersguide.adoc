// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing,
//   software distributed under the License is distributed on an
//   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the License for the
//   specific language governing permissions and limitations
//   under the License.
//
= Integration Testing Framework Users Guide
:author: Karl Heinz Marbaise
:email: khmarbaise@apache.org
:sectnums:
:toc: left

:junit-jupiter: https://junit.org/junit5/[JUnit Jupiter]
:junit-jupiter-extension: https://junit.org/junit5/docs/current/user-guide/#extensions
:junit-jupiter-user-guide: https://junit.org/junit5/docs/current/user-guide/[JUnit Jupiter User Guide]
:junit-jupiter-user-guide-conditional-jre: https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution-jre
:maven-invoker-plugin: https://maven.apache.org/plugins/maven-invoker-plugin[Maven Invoker Plugin]
:maven-plugins: https://maven.apache.org/plugins/[Maven Plugins]
:maven-failsafe-plugin: https://maven.apache.org/surefire/maven-failsafe-plugin/[Maven Failsafe Plugin]
:mock-repository-manager: https://www.mojohaus.org/mrm/index.html[Mock Repository Manager]
:backgorund-guide: https://khmarbaise.github.io/maven-it-extension/itf-documentation/background/background.html
:itf-issues: https://github.com/khmarbaise/maven-it-extension/issues
:assertj: https://assertj.github.io/doc/

:itfexample: _basedir/../..

== Overview

This document intends to give a comprehensive reference for programmers writing
integration tests for Maven Plugins / Maven Core Extensions / Maven Core.

=== What is Integration Testing Framework?
The Integration Testing Framework (ITF for short) is in its foundation a {junit-jupiter-extension}[JUnit Jupiter Extension]
which supports you in writing integration tests for Maven Plugins etc. There are several aspects
that makes writing integration tests for Maven Plugins at the
{backgorund-guide}[moment harder than it should be]. This is the reason why this framework exists.

=== Status

The current status of this extension is experimental while some people call it Proof of Concept (PoC).

== About this Guide

This guide represents the current state of development and things which work (or more accurate: **should work**).
If you find things which do not work as described here or even don't work please don't hesitate
to {itf-issues}[create an appropriate issue] and describe what does not work or does not work at
all as described or maybe does not work as you might expect it to work.

WARNING: This guide is of course not a guarantee that it works cause the project is in a very
early stage.

== Overview

The idea of integration tests for Maven Plugins, Maven Extensions, Maven Core is to keep the
functionality the way it has been defined independent of refactoring code or improving
functionality.

This maven integration test framework is an extension for {junit-jupiter}. The usage of JUnit Jupiter
already gives a lot of support for things which are very useful while writing unit- and integration
tests. The idea of testing is to express the requirements in code. Those are in other words
the tests which should be written.

If you are not familiar with JUnit Jupiter I strongly recommend reading the
{junit-jupiter-user-guide} first.

The expressiveness of tests is a very important part of writing integration tests or
test in general. If a test is not easy to understand it is very likely not being written.

Let us take a look into the following test code example which gives you an impression how an integration
test for a {maven-plugins}/Maven Extensions/Maven-Core should look like:

[source,java]
----
package org.it;

import static org.assertj.core.api.Assertions.assertThat;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

@MavenJupiterExtension // <1>
class FirstMavenIT {

  @MavenTest // <2>
  void the_first_test_case(MavenExecutionResult result) { //<3>
    assertThat(result).build().isSuccessful(); // <4>
  }

}
----
<1> The Maven Integration test annotation
<2> The Maven Test annotation.
<3> The result of the execution is injected into the test method (details in Chapter link:[Needs to be written])
<4> The above used assertions like `assertThat(..)` are custom assertions which will be
explained in link:#_assertions[Assertions chapter].


//FIXME: link to chapter for assertions.
<<<
== Configuration in Maven

=== Users Point of View

You are a user who want to use the integration test framework to write integration tests for a plugin etc.
This area shows how to configure the integration test framework in your Maven build and what kind of requirements
exist.

The prerequisites to use this integration test framework is that you are running JDK8 at minimum for your tests.
This is based on using {junit-jupiter-extension}[JUnit Jupiter Extension] and of course on the implemented code
of this extension.

The requirements are:

* JDK8+
* Apache Maven 3.1.0 or above.

The first step is to add the appropriate dependencies to your project. They are usually with `test` scope
cause you only need them during the integration tests.

[source,xml]
----
include::{itfexample}/itf-examples/pom.xml[tag=dependencies]
----
The dependency `com.soebes.itf.jupiter.extension:itf-assertj` contains custom assertions of {assertj}[AssertJ]
in case you want to use {assertj}[AssertJ] as your assertion framework. This means you have to include
`org.assertj:assertj-core` as well. If you don't want to use AssertJ as assertion framework you can omit them both.

Now you have to have the dependency `org.junit.jupiter:junit-jupiter-engine` to get tests running with
{junit-jupiter} and finally you have to add the `com.soebes.itf.jupiter.extension:itf-jupiter-extension` dependency to
get the support for your Maven integration tests.

//TODO: Need to reconsider? More details? Or a separate paragraph about that.
Based on the described structures the content (with the projects which is used as test) from
`src/test/resources-its` has to be copied into `target/test-classes` which usually means including
filtering. This is used to replace placeholders in files like `@project.version@` and replace with
the real version of your extension/plugin etc. You have to be careful which delimiter you have
chosen. So you might need to tweak your configuration based on your choices.

[source,xml]
----
include::{itfexample}/itf-examples/pom.xml[tag=resources]
----

The next thing is to configure the `itf-maven-plugin` with the `install` goal
like this:

[source,xml]
----
include::{itfexample}/itf-examples/pom.xml[tag=itf-maven-plugin]
----
//FIXME: Needed to be changed after itf-maven-plugin will run also the tests.
The `itf-maven-plugin` copies the code of your extension/plugin into appropriate directories which are used during the
integration tests.

Finally you have to add a configuration for {maven-failsafe-plugin} like the following:

[source,xml]
----
include::{itfexample}/itf-examples/pom.xml[tag=failsafe]
----
The given properties like `maven.version` transfers the version of Maven which is used
within the `itf-jupiter-extension` to run your integration tests and the `maven.home` transfers the
information of where to find the current Maven installation. This is needed to start the Maven process
from within the integration tests.
//TODO: Check if we can omit maven.home cause we are searching already via PATH?

The usage of {maven-failsafe-plugin} implies the naming convention for the integration
tests like `*IT.java` but of course you can change that by using the appropriate configuration if you like or need to.

The above describe configuration will make it possible to run all tests via command line by using `mvn clean verify`.


IMPORTANT: It is also possible to run the integration tests from your IDE. This only works if you have done the
`mvn clean verify` once before on command line. Then you can run the integration tests from your IDE as long as you
don't change the code of the plugin/extension etc. which is under test. You can change the tests without any limitation
(If you find any please create an issue for that.)

NOTE: The whole given configuration which comprises of `itf-maven-plugin` and the
configuration for `maven-failsafe-plugin` should be replaced by separate maven plugin later to make the usage
more convenient.

=== Developers Point of View

You are a potential contributor or just interested in how the code of this extension is working/looks like or you are a
user who want to test with the bleeding edge of this extension.

The requirements for building this extensions are:

* JDK8+ (need to reconsider)
* https://maven.apache.org/[Apache Maven 3.6.0+]

You have to clone the git repository and you can build the extension simply via: `mvn clean install`. The `install` is
needed to install the created artifacts into your local repository for reuse.


<<<
== Structuring Integration Tests

=== A Single Test Case
The location of an integration test defaults to `src/test/java/<package>/FirstMavenIT.java`.
The selected naming schema like `<any>IT.java` implies that it will be executed by the
{maven-failsafe-plugin} by convention. This will lead us in a directory structure as follows:
[source]
----
.
└── src/
    └── test/
        └── java/
            └── org/
                └── it/
                    └── FirstMavenIT.java

----
In case of an integration test for a Maven plugin/extension or others we need to be able to
define also the projects which are the *real test cases* (Maven projects).
This needs to be put somewhere in the directory tree to be easily associated with the given
test `FirstMavenIT`.

The project to be used as an test case is implied to be located into
`src/test/resources-its/<package>/FirstMavenIT` this looks like this:
//TODO: should we keep the location `resources-its` ?
[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── FirstMavenIT/
----
Currently this location is separated from all other resources directories to make filtering easier
which has to be configured within your `pom.xml` file and preventing interfering with other
configurations.

We have an integration test class for example `FirstMavenIT` but what if we like to write several
test cases? So we need to make separation between different *test cases* which can be achieved by
using the *method name* within the test class `FirstMavenIT` which is `the_first_test_case` in our
example. This results in the following directory layout:

[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── FirstMavenIT/
                        └── the_first_test_case/
                            ├── src/
                            └── pom.xml
----
This approach gives us the opportunity to write several integration test cases within a
single test class `FirstMavenIT` and also separates them easily.
The usage of the *method name* implies some limitations based on the naming rules for *method names*.
The best practice is to write *method names* with lowercase letters and separate words by using an
underscore `_`. This will prevent issues with case insensitive file systems.

=== Test Case Execution

During the execution of the integration tests the following directory structure will be created
within the `target` directory:
[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── FirstMavenIT/
                   └── the_first_test_case/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       ├── mvn-arguments.log
                       └── orther logs.
----
Based on the above you can see that each *test case* (method within the test class `FirstMavenIT`)
has it's own local repository (aka local cache) `.m2/repository`. Furthermore you see that the
project is built within the `project` directory. This gives you a view of the built project as you
did on plain command line and take a look into it. The output of the build is written into
`mvn-stdout.log` (stdout) and the output to stderr is written to `mvn-stderr.log`. The used
command line parameters to call Maven are put into `mvn-arguments.log`.

//TODO: Define `other logs` ? environment output, command line parameters ?
//FIXME: Needs to be implemented

=== Several Test Cases
If we like to define several integration test cases within a single test class `SeveralMavenIT`
we have to define different methods which are the test cases. This results in the following
class layout:
[source,java]
----
package org.it;

import static org.assertj.core.api.Assertions.assertThat;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

@MavenJupiterExtension
class SeveralMavenIT {

  @MavenTest
  void the_first_test_case(MavenExecutionResult result) {
     ...
  }
  @MavenTest
  void the_second_test_case(MavenExecutionResult result) {
     ...
  }
  @MavenTest
  void the_third_test_case(MavenExecutionResult result) {
     ...
  }
}
----
The structure for the Maven projects which are used by each of the test cases (*method names*)
looks like the following:
[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── SeveralMavenIT/
                        ├── the_first_test_case/
                        │   ├── src/
                        │   └── pom.xml
                        ├── the_second_test_case/
                        │   ├── src/
                        │   └── pom.xml
                        └── the_this_test_case/
                            ├── src/
                            └── pom.xml
----
After running the integration tests the resulting directory structure in the `target`
directory will look like this:
[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── SeveralMavenIT/
                   ├── the_first_test_case/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   ├── the_second_test_case/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── the_third_test_case/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── mvn-arguments.log
----
Based on the structure you can exactly dive into each test case separately and take
a look at the console output of the test case via `mvn-stdout.log` or maybe in case of errors
in the `mvn-stderr.log`. In the `project` directory you will find the usual `target` directory
which contains the Maven output which might be interesting as well. Furthermore the
local cache (aka maven repository) is available separately for each test case and can be found
in the `.m2/repository` directory.

<<<

== Goals, Properties and Command Line Options

=== Goals

In each test case method you define `@MavenTest` which says execute Maven with the given
default goals and parameters. A typical integration test looks like this:
[source,java]
.BasicIT.java
----
@MavenJupiterExtension
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
So now the question is: Which goals and parameters will be used to execute Maven for the `first`
test case? In general the `MavenJupiterExtension` annotation defines a default set of goals which will be executed
if not defined otherwise. The default for goals in `MavenJupiterExtension` is `package`. That means if we keep
the test as in our example maven would be called like `mvn package`. From a technical perspective
some other parameters have been added which is `mvn -Dmaven.repo.local=Path package`.
The `-Dmaven.repo.local=..` is needed to make sure that each call uses the defined local cache
(See link:_common_maven_cache[Common Maven Cache]).
You can of course change the default for the goal if you like by simply changing the parameter for
`@MavenJupiterExtension(goals = {"install"})` that would mean to execute all subjacent tests like `mvn -D.. install`
instead of `mvn -D .. package`. A usual command parameter set includes
`--batch-mode` and `-V` (This can't be changed currently.).

How could you write a test which uses a plugin goal instead? You can simply define the
goal(s) with the `@MavenTest` annotation like this:

[source,java]
----
@MavenTest( goals = {"${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies"})
----

The used `goals` in the above `@MavenTest` will overwrite any goal which is defined by `MavenJupiterExtension`. The `goals`
also supports replacement of placeholders where currently the following are supported:

* ${project.groupId}
* ${project.artifactId}
* ${project.version}

Those are the ones which are used in the majority of cases for Maven plugins. If you like to
call several goals and/or lifecycle parts in one go you can simply define it like this:

[source,java]
----
@MavenTest( goals = {
    "${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies",
    "site:stage",
    "install"
})
void test_case(MavenExecutionResult result) {
..
}
----

The equivalent on command line would be:
[source,bash]
----
mvn ${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies site:stage install
----

=== SystemProperties

There are situations where you need to use system properties which are usually defined on command like this:
[source,bash]
----
mvn versions:set -DgenerateBackups=false -DnewVersion=2.0
----
This can be achieved by enhancing the `@MavenTest` annotation with `systemProperties` which could look like this:

[source,java]
.CompareDependenciesIT.java
----
package org.codehaus.mojo.versions.it;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;
import com.soebes.itf.jupiter.maven.MavenProjectResult;

import com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;

@MavenJupiterExtension
class CompareDependenciesIT
{
    @MavenTest( goals = {"${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies"},
                systemProperties = {
                    "remotePom=localhost:dummy-bom-pom:1.0",
                    "reportOutputFile=target/depDiffs.txt"}
               )
    void it_compare_dependencies_001( MavenExecutionResult result )
    {
       ...
    }
}
----

=== Command Line Options
In different scenarios it is needed to define command line options for example `--non-recursive` etc.
This can be done by using the `options` part of `@MavenTest`. There is a convenience class
`MavenOptions` available which contains all existing command line options. You are not forced to
use the `MavenOptions` class.

[source,java]
----
@MavenTest( options = {MavenOptions.NON_RECURSIVE, "--offline"},
            goals = {"${project.groupId}:${project.artifactId}:${project.version}:set"},
            systemProperties = {"newVersion=2.0"} )
void first( MavenExecutionResult result )
{
    assertThat( result ).isSuccessful();
}
----
This gives you the choice to decide to use `MavenOptions` or not:
[source,java]
----
@MavenTest( options = {"-N", "--offline"},
            goals = {"${project.groupId}:${project.artifactId}:${project.version}:set"},
            systemProperties = {"newVersion=2.0"} )
void first( MavenExecutionResult result )
{
    assertThat( result ).isSuccessful();
}
----

<<<
== Scenarios

=== Grouping Test Cases
Sometimes it makes sense to group test into different groups together. This can be achieved
via the `@Nested` annotation which is provided by {junit-jupiter}. This would result in
a test class like this:
[source,java]
.MavenIntegrationGroupingIT.java
----
@MavenJupiterExtension
class MavenIntegrationGroupingIT {

  @MavenTest
  void packaging_includes(MavenExecutionResult result) {
  }

  @Nested
  class NestedExample {

    @MavenTest
    void basic(MavenExecutionResult result) {
    }

    @MavenTest
    void packaging_includes(MavenExecutionResult result) {
    }

  }
}
----
After test execution the resulting directory tree looks like this:
[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── MavenIntegrationGroupingIT/
                   ├── packaging_includes/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── NestedExample/
                       ├── basic/
                       │   ├── .m2/
                       │   ├── project/
                       │   │   ├── src/
                       │   │   ├── target/
                       │   │   └── pom.xml
                       │   ├── mvn-stdout.log
                       │   ├── mvn-stderr.log
                       │   └── other logs
                       └── packaging_includes/
                           ├── .m2/
                           ├── project/
                           │   ├── src/
                           │   ├── target/
                           │   └── pom.xml
                           ├── mvn-stdout.log
                           ├── mvn-stderr.log
                           └── other logs
----


=== Common Maven Cache

In all previous test case examples the maven cache (aka maven repository)
is created separately for each of the test cases (*test methods*). There are times
where you need to have a common cache (aka maven repository) for two or more test
cases together. This can be achieved easily via the `@MavenRepository`
annotation.footnote:[Base on the usage of this annotation the parallelizing is automatically deactivated
cause Maven has never been designed to make a parallel access to the maven cache possible.]
The usage looks like the following:

[source,java]
.MavenIntegrationExampleNestedGlobalRepoIT.java
----
package org.it;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenRepository;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

@MavenJupiterExtension
@MavenRepository
class MavenITWithGlobalMavenCacheIT {

  @MavenTest
  void packaging_includes(MavenExecutionResult result) {
  }

  @MavenTest
  void basic(MavenExecutionResult result) {
  }

}
----

After test execution the resulting directory tree looks like this:
[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── MavenITWithGlobalMavenCacheIT/
                   ├── .m2/
                   ├── packaging_includes/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── basic/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── other logs
----
There you see that the `.m2/` directory (maven local cache) is directly located
under the `MavenITWithGlobalMavenCacheIT` directory which is the equivalent of the
`MavenITWithGlobalMavenCacheIT` class.

The usage of `@MavenRepository` is also possible in combination with `@Nested` annotation which
will look like this:

[source,java]
.MavenIntegrationGroupingIT.java
----
@MavenJupiterExtension
class MavenIntegrationGroupingIT {

  @MavenTest
  void packaging_includes(MavenExecutionResult result) {
  }

  @Nested
  @MavenRepository
  class NestedExample {

    @MavenTest
    void basic(MavenExecutionResult result) {
    }

    @MavenTest
    void packaging_excludes(MavenExecutionResult result) {
    }

  }
}
----
That would result in having a common cache for the methods `basic` and `packaging_includes` within
the nested class `NestedExample`. The test method `packaging_includes` will have a cache on it's own.
The directory tree looks like this:

[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── MavenIntegrationGroupingIT/
                   ├── packaging_includes/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── NestedExample/
                       ├── .m2/
                       ├── basic/
                       │   ├── project/
                       │   │   ├── src/
                       │   │   ├── target/
                       │   │   └── pom.xml
                       │   ├── mvn-stdout.log
                       │   ├── mvn-stderr.log
                       │   └── other logs
                       └── packaging_excludes/
                           ├── project/
                           │   ├── src/
                           │   ├── target/
                           │   └── pom.xml
                           ├── mvn-stdout.log
                           ├── mvn-stderr.log
                           └── other logs
----


=== Predefined Repository Content for Tests

There are existing test cases in which you need predefined dependencies cause you can't rely
on existing dependencies in the central repository or anywhere else.
You have the option to define a repository either per testcase or per test class where you
can put existing dependencies for your test cases.
Those dependencies are behaving like you have installed in your local repository via `mvn install:install-file`.

In your test code the setup looks like the following. The important part is the definition
of the `@MavenPredefinedRepository` which indicated that the predefined repository in the appropriate
location needs to exist. This means that those dependencies from this directory are available for
each test case (`project_001` and `proeject_002`) in this test class.

[source,java]
.ProjectIT.java
----
@MavenJupiterExtension
@MavenPredefinedRepository
class ProjectIT {

  @MavenTest(options = {MavenOptions.DEBUG})
  void project_001(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }

  @MavenTest(options = {MavenOptions.DEBUG})
  void project_002(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }

}
----
In your test project definition you need to create the appropriate directory structure
including the needed content which looks like this:

[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── ProjectIT/
                        ├── .predefined-repo
                        │     ├── ...
                        │     └── ...
                        └── project_001/
                        │   ├── src/
                        │   └── pom.xml
                        └── project_002/
                            ├── src/
                            └── pom.xml
----
In the `.predefined-repo` you have to follow a usual maven repository structure. You can of course
define the `@MavenPredefinedRepository` also on the test method level which would look like this:

[source,java]
.ProjectLevelIT.java
----
@MavenJupiterExtension
class ProjectIT {

  @MavenTest(options = {MavenOptions.DEBUG})
  @MavenPredefinedRepository
  void project_001(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }

  @MavenTest(options = {MavenOptions.DEBUG})
  @MavenPredefinedRepository
  void project_002(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }

}
----
The setup directories look like this:
[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── ProjectIT/
                        └── project_001/
                        │   ├── .predefined-repo
                        │   ├── src/
                        │   └── pom.xml
                        └── project_002/
                            ├── .predefined-repo
                            ├── src/
                            └── pom.xml
----

=== Single Project With Several Executions

Sometimes you need to execute a consecutive number of commands (usually maven executions) on the same
single project. This means in the end having a single project and executing several maven execution
on that project. Such a use case looks like this:

[source,java]
.SetIT.java
----
@MavenJupiterExtension
class SetIT
{
    private static final String VERSIONS_PLUGIN =
      "${project.groupId}:${project.artifactId}:${project.version}";

    @Nested
    @MavenProject
    @TestMethodOrder( OrderAnnotation.class )
    class set_001
    {

        @MavenTest(
            options = MavenOptions.NON_RECURSIVE,
            goals = {VERSIONS_PLUGIN + ":set"},
            systemProperties = {"newVersion=2.0"} )
        @Order(10)
        void first( MavenExecutionResult result )
        {
            assertThat( result ).isSuccessful();
        }

        @MavenTest(
            options = MavenOptions.NON_RECURSIVE,
            goals = {VERSIONS_PLUGIN + ":set"},
            systemProperties = {
                "newVersion=2.0",
                "groupId=*",
                "artifactId=*",
                "oldVersion=*"} )
        @Order(20)
        void second( MavenExecutionResult result)
        {
            assertThat( result ).isSuccessful();
        }
    }

}

----
The important part here is the `@MavenProject` annotation which marks the nested class as a container
which contains executions (`first` and `second`) with conditions on the same single project.
The `@MavenProject` defines that project name which is by default `maven_project`.
This means you have to define the project you would like to test on like this:
[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── SetIT/
                        └── set_001/
                            └── maven_project/
                                ├── src/
                                └── pom.xml
----

After test execution it looks like this:

[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── SetIT/
                   └── set_001/
                       └── maven_project/
                           ├── .m2/
                           ├── project/
                           │   ├── src/
                           │   ├── target/
                           │   └── pom.xml
                           ├── first-mvn-arguments.log
                           ├── first-mvn-stdout.log
                           ├── first-mvn-stderr.log
                           ├── second-mvn-arguments.log
                           ├── second-mvn-stdout.log
                           └── second-mvn-stderr.log
----
Each test case defined by the method name `first` and `second` has been executed on the same
project `maven_project`. Each execution has it's own sets of log files which can be identified
by the prefix based on the method name like `first-mvn-arguments.log` etc.

The `@MavenProject` annotation can only be used on a nested class or on the test class itself
(where `MavenJupiterExtension` is located.). If you like to change the name of the project `maven_project` into
something different this can be achieved by using `@MavenProject("another_project_name")`.

== Test Case Execution


=== Conditionally Executing Tests

You might want to run an integration test only for a particular Maven version for example running
only for Maven 3.6.0? So how could you express this? The following code will show how you can do
that.

[source,java]
.ForthMavenIT.java
----
import static com.soebes.itf.extension.assertj.MavenCacheResultAssert.assertThat;
import static com.soebes.itf.jupiter.maven.MavenVersion.M3_0_5;
import static com.soebes.itf.jupiter.maven.MavenVersion.M3_6_0;

import com.soebes.itf.jupiter.extension.DisabledForMavenVersion;
import com.soebes.itf.jupiter.extension.EnabledForMavenVersion;
import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

@MavenJupiterExtension
class FirstMavenIT {

  @MavenTest
  @EnabledForMavenVersion(M3_6_0)
  void first_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isSuccessful();
  }

  @DisabledForMavenVersion(M3_0_5)
  @MavenTest
  void second_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isFailure();
  }

}
----

If you like to disable some tests on a particular Java version this can be handled via
{junit-jupiter-user-guide-conditional-jre}[conditions like this].

//TODO: Make reference to JUnit Jupiter Manual
[source,java]
----
import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;
import static com.soebes.itf.jupiter.maven.MavenVersion.M3_0_5;
import static com.soebes.itf.jupiter.maven.MavenVersion.M3_6_0;

import com.soebes.itf.jupiter.extension.DisabledForMavenVersion;
import com.soebes.itf.jupiter.extension.EnabledForMavenVersion;
import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;
import org.junit.jupiter.api.condition.DisabledOnJre;
import org.junit.jupiter.api.condition.JRE;

@MavenJupiterExtension
@DisabledOnJre(JRE.JAVA_10)
class FirstMavenIT {

  @MavenTest
  @EnabledForMavenVersion(M3_6_0)
  void first_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isSuccessful();
  }

  @DisabledForMavenVersion(M3_0_5)
  @MavenTest
  void second_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isFailure();
  }
}
----

[#_assertions]
== Assertions

=== Overview
Let us take a look into a simple integration test. We would like to concentrate on the assertion part.
[source,java]
----
@MavenJupiterExtension
class FirstIT {
  @MavenTest
  void the_first_test_case(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }
}
----
After the test has run the resulting directory structure looks like this:
[source,text]
----
.
└──target/
   └── maven-its/
       └── org/
           └── it/
               └── FirstIT/
                   └── the_first_test_case/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── other logs
----
In each integration test you should let inject `MavenExecutionResult result` as a parameter of your
test case method cause that gives you the opportunity to write assertion on the result of the maven
execution or what has written into the resulting structure.

Let us start with two general assertions:

* `assertThat(result).isSuccessful();` The build was successful (return code of Maven run 0).
* `assertThat(result).isFailure();` The build has failed (return code of Maven run != 0).

Sometimes this is sufficient but more often you have more complex scenarios to be checked.

Based on the directory structure in the result you can make assumptions about the
names which can be used in your assertions like the following:

//Check issue-25
* `assertThat(result).project()....` which will go into the `project` directory
* `assertThat(result).cache()...` will go into the `.m2/repository` directory.
* `assertThat(result).log()..' will result into the access of the `mvn-stdout.log` file.
// FIXME: https://github.com/khmarbaise/maven-it-extension/issues/26
// FIXME: * Reconsider how it should look like: result).log().stdout() or alike?
// FIXME: * `assertThat(result).stdout()..' will result into the access of the `mvn-stdout.log` file.
// FIXME: * `assertThat(result).stderr()..' will result into the access of the `mvn-stderr.log` file.

So next will be to check that a file in the `target` directory has been created during a test and
should contain the required content. How should that be expressed? The following gives you an example
how you can achieve that:
[source,java]
----
assertThat( result ).isSuccessful()
  .project()
  .hasTarget()
    .withFile( "depDiffs.txt" )
      .hasContent( String.join( "\n",
          "The following differences were found:",
          "",
          "  none", "",
          "The following property differences were found:",
          "",
          "  none" ) );
----
The first part `.isSuccessful()` checks that the build has gone fine than we go into `project`
directory and via `withTarget()` we check the existence of the `target` directory as well as going
into that directory. Finally we append `withFile(...)` which selects which file and redirects to
the `AbstractFileAssert<?>` of AssertJ which gives you the choice to check the content of the file
as you like.

[source,java]
----
assertThat(project).hasTarget()
    .withEarFile()
    .containsOnlyOnce("META-INF/application.xml", "META-INF/appserver-application.xml");

----


=== Expressing Assertions


[source,java]
.CompareDependenciesIT.java
----
package org.codehaus.mojo.versions.it;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;
import com.soebes.itf.jupiter.maven.MavenProjectResult;

import com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;

@MavenJupiterExtension
class CompareDependenciesIT
{
    @MavenTest(
      goals =
        {"${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies"},
      systemProperties = {
          "remotePom=localhost:dummy-bom-pom:1.0",
          "reportOutputFile=target/depDiffs.txt"
      } )
    void it_compare_dependencies_001( MavenExecutionResult result )
    {
        assertThat( result ).isSuccessful()
          .project()
          .hasTarget()
          .withFile( "depDiffs.txt" )
          .hasContent( String.join( "\n",
            "The following differences were found:",
            "",
            "  none",
            "",
            "The following property differences were found:",
            "",
            "  none" ) );
    }
}
----