// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing,
//   software distributed under the License is distributed on an
//   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the License for the
//   specific language governing permissions and limitations
//   under the License.
//
= Integration Testing Framework Users Guide
Karl Heinz Marbaise; {docdate}
:author: Karl Heinz Marbaise
:appendix-number:
:sectnums:
:sectlinks:
:xrefstyle: full
:toc: left
//
:junit-jupiter: https://junit.org/junit5/[JUnit Jupiter]
:junit-jupiter-extension: https://junit.org/junit5/docs/current/user-guide/#extensions
:junit-jupiter-user-guide: https://junit.org/junit5/docs/current/user-guide/[JUnit Jupiter User Guide]
:junit-jupiter-user-guide-conditional-jre: https://junit.org/junit5/docs/current/user-guide/#writing-tests-conditional-execution-jre
:maven-invoker-plugin: https://maven.apache.org/plugins/maven-invoker-plugin[Maven Invoker Plugin]
:maven-plugins: https://maven.apache.org/plugins/[Maven Plugins]
:maven-failsafe-plugin: https://maven.apache.org/surefire/maven-failsafe-plugin/[Maven Failsafe Plugin]
:mock-repository-manager: https://www.mojohaus.org/mrm/index.html[Mock Repository Manager]
:backgorund-guide: https://khmarbaise.github.io/maven-it-extension/itf-documentation/background/background.html
:itf-issues: https://github.com/khmarbaise/maven-it-extension/issues
:assertj: https://assertj.github.io/doc/
//
:itfexample: _basedir/../..

== Overview

The documentation intends to give a comprehensive reference for programmers writing
integration tests for Maven Plugins / Maven Core Extensions / Maven Core.

=== What is Integration Testing Framework?
The Integration Testing Framework (ITF for short) is in its foundation a {junit-jupiter-extension}[JUnit Jupiter Extension],
which supports you in writing integration tests for Maven Plugins etc. There are several aspects,
that makes writing integration tests for Maven Plugins at the
{backgorund-guide}[moment harder than it should be]. This is the reason, why this framework exists.

=== Status

The current status of this extension is experimental while some people call it Proof of Concept (PoC).
This framework has not yet reached version `1.0.0` which means that anything can change, but I try
to keep compatibility as much as possible. I will only break it if really needed. In such cases it will
be documented in the release notes. I strongly recommend reading the release notes.

== About this Guide

This guide represents the current state of development and things, which work (or more accurate: **should work**).
If you find things which do not work as described here or even don't work at all, please don't hesitate
to {itf-issues}[create an appropriate issue] and describe what does not work or does not work at
all as described or maybe does not work as you might expect it to work.

WARNING: This guide is of course not a guarantee that it works, cause the project is in a very
early stage.

== Overview

The idea of integration tests for Maven Plugins, Maven Extensions, Maven Core is to keep the
functionality the way it has been defined independent of refactoring code or improving
functionality.

This maven integration test framework is an extension for {junit-jupiter}. The usage of JUnit Jupiter
already gives a lot of support for things, which are very useful while writing unit- and integration
tests. The idea of testing is to express the requirements in code. Those are in other words
the tests, which should be written.

If you are not familiar with JUnit Jupiter, I strongly recommend reading the
{junit-jupiter-user-guide} first.

The significance of tests is a very important part of writing integration tests or
test in general. If a test is not easy to understand, it is very likely not being written.

Let us take a look into the following test code example which gives you an impression, how an integration
test for a {maven-plugins}/Maven Extensions/Maven-Core should look like:

[source,java]
----
package org.it;

import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

@MavenJupiterExtension // <1>
public class FirstMavenIT {

 @MavenTest // <2>
 void the_first_test_case(MavenExecutionResult result) { //<3>
  assertThat(result).isSuccessful(); // <4>
 }

}
----
<1> The Maven Integration test annotation
<2> The Maven Test annotation.
<3> The result of the execution injected into the test method (details in Chapter link:[Needs to be written])
<4> The above used assertions like `assertThat(..)` are custom assertions which will be
explained in link:#_assertions[Assertions chapter].


//FIXME: link to chapter for assertions.
<<<
== Configuration in Maven

=== User's Point of View

You are a user who want to use the integration test framework to write integration tests for a plugin etc.
This area shows how to configure the integration test framework in your Maven build and what kind of requirements
exist.

The prerequisites to use this integration test framework is, that you are running JDK8 at minimum for your tests.
This is based on using {junit-jupiter-extension}[JUnit Jupiter Extension] and of course on the implemented code
of this extension.

The requirements are:

* JDK8+
* Apache Maven 3.1.0 or above.

The first step is to add the appropriate dependencies to your project. They are usually with `test` scope,
cause you only need them during the integration tests.

[source,xml]
----
include::{itfexample}/itf-examples/pom.xml[tag=dependencies]
----
The dependency `com.soebes.itf.jupiter.extension:itf-assertj` contains custom assertions of {assertj}[AssertJ]
in case you want to use {assertj}[AssertJ] as your assertion framework. This means you have to include
`org.assertj:assertj-core` as well. If you don't want to use AssertJ as assertion framework you can omit them both.

Now you have to have the dependency `org.junit.jupiter:junit-jupiter-engine` to get tests running with
{junit-jupiter} and finally you have to add the `com.soebes.itf.jupiter.extension:itf-jupiter-extension` dependency to
get the support for your Maven integration tests.

//TODO: Need to reconsider? More details? Or a separate paragraph about that.
Based on the described structures the content (with the projects which is used as test) from
`src/test/resources-its` has to be copied into `target/test-classes` which usually means including
filtering. This is used to replace placeholders in files like `@project.version@` and replace with
the real version of your extension/plugin etc. so you can use the `itf-maven-plugin` which is doing
this job on it's own which means you don't have to do something special here.

The next thing is to configure the `itf-maven-plugin` with the `install` and the `resources-its` goal
like this:

[source,xml]
----
include::{itfexample}/itf-examples/pom.xml[tag=itf-maven-plugin]
----
//FIXME: Needed to be changed after itf-maven-plugin will run also the tests.
The `itf-maven-plugin` copies the code of your extension/plugin into appropriate directories which are
used during the integration tests. Further more it will handle the copying of the structure from
`src/test/resources-its` into the correct location and will also handle the filtering as described above.

Finally you have to add a configuration for {maven-failsafe-plugin} like the following:

[source,xml]
----
include::{itfexample}/itf-examples/pom.xml[tag=failsafe]
----
The given properties like `maven.version` transfers the version of Maven which is used
within the `itf-jupiter-extension` to run your integration tests and the `maven.home` transfers the
information of where to find the current Maven installation. This is needed to start the Maven process
from within the integration tests.
//TODO: Check if we can omit maven.home cause we are searching already via PATH?

The usage of {maven-failsafe-plugin} implies the naming convention for the integration
tests like `*IT.java` but of course you can change that by using the appropriate configuration if you like or need to.

The above described configuration will make it possible to run all tests via command line by using `mvn clean verify`.


IMPORTANT: It is also possible to run the integration tests from your IDE. This only works if you have done the
`mvn clean verify` once before on command line. Then you can run the integration tests from your IDE as long as you
don't change the code of the plugin/extension etc. which is under test. You can change the tests without any limitation
(If you find any please create an issue for that.)

NOTE: The whole given configuration which comprises of `itf-maven-plugin` and the
configuration for `maven-failsafe-plugin` should be replaced by separate maven plugin later to make the usage
more convenient.

=== Developer's Point of View

You are a potential contributor or just interested in how the code of this extension is working/looks like or you are a
user who wants to test with the bleeding edge of this extension.

The requirements for building this extensions are:

* JDK8+ (need to reconsider)
* https://maven.apache.org/[Apache Maven 3.6.0+]

You have to clone the git repository and you can build the extension simply via: `mvn clean install`. The `install` is
needed to install the created artifacts into your local repository for reuse.


<<<
== Structuring Integration Tests

=== A Single Test Case
The location of an integration test defaults to `src/test/java/<package>/FirstMavenIT.java`.
The selected naming schema like `<any>IT.java` implies that it will be executed by the
{maven-failsafe-plugin} by convention. This will lead us to a directory structure as follows:
[source]
----
.
└── src/
    └── test/
        └── java/
            └── org/
                └── it/
                    └── FirstMavenIT.java

----
In case of an integration test for a Maven plugin/extension or others, we need to be able to
define also the projects which are the *real test cases* (Maven projects).
This needs to be put somewhere in the directory tree to be easily associated with the given
test `FirstMavenIT`.

The project to be used as a test case implies to be located into
`src/test/resources-its/<package>/FirstMavenIT`, this looks like this:
//TODO: should we keep the location `resources-its` ?
[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── FirstMavenIT/
----
Currently this location is separated from all other resources directories to make filtering easier,
what has to be configured within your `pom.xml` file and preventing interfering with other
configurations.

We have an integration test class for example `FirstMavenIT` but what if we like to write several
test cases? So we need to make separation between different *test cases* which can be achieved by
using the *method name* within the test class `FirstMavenIT` which is `the_first_test_case` in our
example. This results in the following directory layout:

[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── FirstMavenIT/
                        └── the_first_test_case/
                            ├── src/
                            └── pom.xml
----
This approach gives us the opportunity to write several integration test cases within a
single test class `FirstMavenIT` and also separates them easily.
The usage of the *method name* implies some limitations based on the naming rules for *method names*.
The best practice is to write *method names* with lowercase letters and separate words by using an
underscore `_`. This will prevent issues with case insensitive file systems.

=== Test Case Execution

During the execution of the integration tests the following directory structure will be created
within the `target` directory:
[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── FirstMavenIT/
                   └── the_first_test_case/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       ├── mvn-arguments.log
                       └── orther logs.
----
Based on the above you can see that each *test case* (method within the test class `FirstMavenIT`)
has its own local repository (aka local cache) `.m2/repository`. Furthermore you see that the
project is being built within the `project` directory. This gives you a view of the built project as you
did on plain command line and take a look into it. The output of the build has been written into
`mvn-stdout.log`(stdout) and the output to stderr is written to `mvn-stderr.log`. The used
 command line parameters to call Maven are wrote into `mvn-arguments.log`.

//TODO: Define `other logs` ? environment output, command line parameters ?
//FIXME: Needs to be implemented

=== Several Test Cases
If we like to define several integration test cases within a single test class `SeveralMavenIT`
we have to define different methods, which are the test cases. This results in the following
class layout:
[source,java]
----
package org.it;

import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

@MavenJupiterExtension
class SeveralMavenIT {

  @MavenTest
  void the_first_test_case(MavenExecutionResult result) {
     ...
  }
  @MavenTest
  void the_second_test_case(MavenExecutionResult result) {
     ...
  }
  @MavenTest
  void the_third_test_case(MavenExecutionResult result) {
     ...
  }
}
----
The structure for the Maven projects, which is used by each of the test cases (*method names*)
looks like the following:
[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── SeveralMavenIT/
                        ├── the_first_test_case/
                        │   ├── src/
                        │   └── pom.xml
                        ├── the_second_test_case/
                        │   ├── src/
                        │   └── pom.xml
                        └── the_this_test_case/
                            ├── src/
                            └── pom.xml
----
After running the integration tests the resulting directory structure in the `target`
directory will look like this:
[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── SeveralMavenIT/
                   ├── the_first_test_case/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   ├── the_second_test_case/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── the_third_test_case/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── mvn-arguments.log
----
Based on the structure you can exactly dive into each test case separately and take
a look at the console output of the test case via `mvn-stdout.log` or maybe in case of errors
in the `mvn-stderr.log`. In the `project` directory you will find the usual `target` directory,
which contains the Maven output which might be interesting as well. Furthermore the
local cache (aka maven repository) is available separately for each test case and can be found
in the `.m2/repository` directory.

<<<

== Goals, Profiles, Properties and Command Line Options

=== Goals

In each test case method you define `@MavenTest` which says execute Maven with the given
default goals and parameters. A typical integration test looks like this:
[source,java]
.BasicIT.java
----
@MavenJupiterExtension
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
So now the question is: Which goals and parameters will be used to execute Maven for the `first`
test case? Very brief the default set of goals which will be executed if not defined otherwise is
`package` (See xref:_default_goalsoptions[for a more detailed explanation]).
That means if we keep the test as in our example maven would be called like `mvn package`.
From a technical perspective some other parameters have been added which are `mvn -Dmaven.repo.local=Path package`.
The `-Dmaven.repo.local=..` is needed to make sure that each call uses the defined local cache
(See xref:_common_maven_cache[Common Maven Cache]).
You can of course change the default for the goal, if you like by simply add the `@MavenGoal` annotation
`@MavenGoal("install")` that would mean to execute all subjacent tests like `mvn -D.. install`
instead of `mvn -D .. package`. A usual command parameter set includes
`--batch-mode` and `-V` (See xref:_default_goalsoptions[for a more detailed explanation]).

How could you write a test which uses a plugin goal instead? You can simply define the
goal(s) via the `@MavenGoal` annotation like this:

[source,java]
----
@MavenGoal("${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies")
@MavenTest
----

The used `@MavenGoal` will overwrite any goal which is predefined. The given goals in `@MavenGoal`
support replacement of placeholders which currently supports the following:

* ${project.groupId}
* ${project.artifactId}
* ${project.version}

Those are the ones which are used in the majority of cases for Maven plugins. If you like to
call several goals and/or lifecycle parts in one go you can simply define it like this:

[source,java]
----
@MavenGoal("${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies")
@MavenGoal("site:stage")
@MavenGoal("install")
@MavenTest
void test_case(MavenExecutionResult result) {
..
}
----

The equivalent on command line would be:
[source,bash]
----
mvn ${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies site:stage install
----

=== Profiles

In some cases you need to activate one or https://maven.apache.org/guides/introduction/introduction-to-profiles.html[more Maven profiles]
for test purposes etc. This can be achieved by using `@MavenProfile` which looks like this:

[source,java]
----
@MavenJupiterExtension
class BasicIT {

  @MavenTest
  @MavenProfile("run-its")
  void first(MavenExecutionResult result) {
  }
----
If you like to activate multiple Maven profiles you can simply repeat the annotation like this:
[source,java]
----
@MavenJupiterExtension
class BasicIT {

  @MavenTest
  @MavenProfile("run-its")
  @MavenProfile("run-e2e")
  void first(MavenExecutionResult result) {
  }
----
An alternative is to use the array like definition like this:
[source,java]
----
@MavenJupiterExtension
class BasicIT {

  @MavenTest
  @MavenProfile({"run-its","run-e2e"})
  void first(MavenExecutionResult result) {
  }
----
The profiles can also be activated for a bunch of test cases that you don't need to add the
annotation on each test case. So you can define the Maven profile on the class level instead.
[source,java]
----
@MavenJupiterExtension
@MavenProfile({"run-its","run-e2e"})
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
----
If you want to explicitly deactivate a profile this can be achieved like this:
[source,java]
----
@MavenJupiterExtension
class BasicIT {

  @MavenTest
  @MavenProfile("+run-its")
  void first(MavenExecutionResult result) {
  }
----
The `+` prefix is responsible for deactivating a given profile during the build. We strongly recommend to use `+`
sign (instead of `!`) to prevent issues on different operating systems.

=== System Properties

There are situations where you need to use system properties which are usually defined on command like this:
[source,bash]
----
mvn versions:set -DgenerateBackups=false -DnewVersion=2.0
----
The equivalent for using such properties (which contains name and value) within
an integration tests can be achieved by using the `@SystemProperty` annotation
which look like this:

[source,java]
.CompareDependenciesIT.java
----
package org.codehaus.mojo.versions.it;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;

@MavenJupiterExtension
class CompareDependenciesIT
{
    @MavenGoal("versions:set")
    @SystemProperty(value = "generateBackups", content = "false")
    @SystemProperty(value = "newVersion", content = "2.0")
    @MavenTest
    void it_compare_dependencies_001( MavenExecutionResult result )
    {
       ...
    }
}
----

In other cases it's only necessary to define the name of the property which you do
on the command like this:
[source,bash]
----
mvn clean verify -DskipTests
----
The same setup can be achieved via:
[source,java]
.CompareDependenciesIT.java
----
package org.codehaus.mojo.versions.it;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;

@MavenJupiterExtension
class RunningIT
{
    @MavenGoal("clean")
    @MavenGoal("verify")
    @SystemProperty("skipTests")
    @MavenTest
    void running( MavenExecutionResult result )
    {
       ...
    }
}
----
During the designing of your integration tests you might realize you need the property
setup for a larger number of integration test cases. You can define a property or
even several properties on a class level like this:

[source,java]
.CompareDependenciesIT.java
----
package org.codehaus.mojo.versions.it;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;

@MavenJupiterExtension
@SystemProperty("skipTests")
class RunningIT
{

    @MavenTest
    void running_first( MavenExecutionResult result )
    {
       ...
    }

    @MavenTest
    void running_second( MavenExecutionResult result )
    {
       ...
    }

    @MavenTest
    void running_thrid( MavenExecutionResult result )
    {
       ...
    }
}
----
This prevents the repetition of the property on each test case method.

=== Command Line Options
In different scenarios it is needed to define command line options for example `--non-recursive` etc.
This can be done by using the `@MavenOption` annotation. There is a convenience class
`MavenCLIOptions` available, which contains all existing command line options. You are not forced to
use the `MavenCLIOptions` class.

[source,java]
----
@MavenGoal("versions:set")
@SystemProperty(value = "newVersion", content = "2.0")
@MavenOption(MavenCLIOptions.NON_RECURSIVE)
@MavenOption("--offline")
@MavenTest
void first( MavenExecutionResult result )
{
    assertThat( result ).isSuccessful();
}
----
This gives you the choice to decide to use `MavenCLIOptions` or not:
[source,java]
----
@MavenGoal("versions:set")
@SystemProperty(value = "newVersion", content = "2.0")
@MavenOption({"-N","--offline"})
@MavenTest
void first( MavenExecutionResult result )
{
    assertThat( result ).isSuccessful();
}
----

=== Default Goals,Options

==== Goals
Basically to run a usual integration test it needs to be defined by which goals and options such
test has to run. Let us take a look at a simple example:
[source,java]
----
@MavenJupiterExtension
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
The execution of the test will run with the goal `package` which is defined by default
if not defined otherwise. There are defined some useful default command line options like
`--errors`, `-V` and `--batch-mode` also by default if not defined otherwise. So let
us take a look what otherwise means.

You can replace the default goal `package` by simply defining a different goal on your test class
like this (you can also put that annotation on the method as well):
[source,java]
----
@MavenJupiterExtension
@MavenGoal("verify")
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
This means all consecutive tests will run with the goal `verify` instead of `package`. It is also
possible to define several goals like this:
[source,java]
----
@MavenJupiterExtension
@MavenGoal("clean")
@MavenGoal("verify")
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
If you don't like to repeat that on each test class you can define a meta annotation like this:

[source,java]
----
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RUNTIME)
@Inherited
@MavenGoal({"clean", "verify"})
public @interface GoalsCleanVerify {
}
----
This meta annotation can now be used instead. This makes it easy to change the goal for all of your tests from
a single location.
[source,java]
----
@MavenJupiterExtension
@GoalsCleanVerify
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
Now let us summarize the information for goals. As long as no explicit `@MavenGoal` is defined the
default will be used which is `package`.

==== Options
Now let us going back to the example:
[source,java]
----
@MavenJupiterExtension
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
This example will run the test with the following command line options:

* `-V`
* `--batch-mode`
* `--errors`

So if you like to change the command line options which are used to run an integration test you
can simply define different options via the appropriate annotations:

[source,java]
----
@MavenJupiterExtension
@MavenOption(MavenCLIOptions.DEBUG)
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
Using the option like this means (like for goals as mentioned before) all consecutive tests will
now run with the given option which in this case is only a single command line option `--debug`
and nothing else. You can add supplemental command line options just by adding supplemental
annotations to your tests like this:
[source,java]
----
@MavenJupiterExtension
@MavenOption(MavenCLIOptions.ERRORS)
@MavenOption(MavenCLIOptions.DEBUG)
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
The MavenOption annotation can also be used to create a meta annotation like this:

[source,java]
----
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RUNTIME)
@Inherited
@MavenOption(MavenCLIOptions.DEBUG)
@MavenOption(MavenCLIOptions.ERRORS)
@MavenOption(MavenCLIOptions.FAIL_AT_END)
public @interface OptionDebugErrorFailAtEnd {
}
----
The newly defined meta annotation can simply being used like this:

[source,java]
----
@MavenJupiterExtension
@OptionDebugErrorFailAtEnd
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
Now let us summarize the information for options. As long as no explicit `@MavenOption` is defined the
default will be used which are the following:

* `-V`
* `--batch-mode`
* `--errors`

==== Combined Annotation
Sometimes you would like to combine things from options and goals in a more convenient way.
That is possible by using a custom annotation like this one:

[source,java]
----
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RUNTIME)
@Inherited
@MavenJupiterExtension
@MavenOption(MavenCLIOptions.DEBUG)
@MavenOption(MavenCLIOptions.ERRORS)
@MavenOption(MavenCLIOptions.FAIL_AT_END)
@MavenGoal("clean")
@MavenGoal("verify")
public @interface MavenJupiterExtensionWithDefaults {
}
----
The given annotation include the usage of `@MavenJupiterExtension` which handles the loading of the
extension part. By using the above defined annotation your test could look like this:

[source,java]
----
@MavenJupiterExtensionWithDefaults
class BasicIT {

  @MavenTest
  void first(MavenExecutionResult result) {
  }
}
----
So this makes it very easy to define your own default set of goals, options or maybe more.
You can of course add properties etc. if you need.

<<<
== Scenarios

=== Grouping Test Cases
Sometimes it makes sense to group test into different groups together. This can be achieved
via the `@Nested` annotation which is provided by {junit-jupiter}. This would result in
a test class like this:
[source,java]
.MavenIntegrationGroupingIT.java
----
@MavenJupiterExtension
class MavenIntegrationGroupingIT {

  @MavenTest
  void packaging_includes(MavenExecutionResult result) {
  }

  @Nested
  class NestedExample {

    @MavenTest
    void basic(MavenExecutionResult result) {
    }

    @MavenTest
    void packaging_includes(MavenExecutionResult result) {
    }

  }
}
----
After test execution the resulting directory tree looks like this:
[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── MavenIntegrationGroupingIT/
                   ├── packaging_includes/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── NestedExample/
                       ├── basic/
                       │   ├── .m2/
                       │   ├── project/
                       │   │   ├── src/
                       │   │   ├── target/
                       │   │   └── pom.xml
                       │   ├── mvn-stdout.log
                       │   ├── mvn-stderr.log
                       │   └── other logs
                       └── packaging_includes/
                           ├── .m2/
                           ├── project/
                           │   ├── src/
                           │   ├── target/
                           │   └── pom.xml
                           ├── mvn-stdout.log
                           ├── mvn-stderr.log
                           └── other logs
----


=== Common Maven Cache

In all previous test case examples the maven cache (aka maven repository)
is created separately for each of the test cases (*test methods*). There are times,
where you need to have a common cache (aka maven repository) for two or more test
cases. This can be achieved easily via the `@MavenRepository`
annotation.footnote:[Based on the usage of this annotation the parallelizing is automatically deactivated,
cause Maven has never been designed to make a parallel access to the maven cache possible.]
The usage looks like the following:

[source,java]
.MavenIntegrationExampleNestedGlobalRepoIT.java
----
package org.it;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenRepository;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

@MavenJupiterExtension
@MavenRepository
class MavenITWithGlobalMavenCacheIT {

  @MavenTest
  void packaging_includes(MavenExecutionResult result) {
  }

  @MavenTest
  void basic(MavenExecutionResult result) {
  }

}
----

After test execution the resulting directory tree looks like this:
[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── MavenITWithGlobalMavenCacheIT/
                   ├── .m2/
                   ├── packaging_includes/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── basic/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── other logs
----
There you see that the `.m2/` directory (maven local cache) is directly located
under the `MavenITWithGlobalMavenCacheIT` directory which is the equivalent of the
`MavenITWithGlobalMavenCacheIT` class.

The usage of `@MavenRepository` is also possible in combination with `@Nested` annotation which,
will look like this:

[source,java]
.MavenIntegrationGroupingIT.java
----
@MavenJupiterExtension
class MavenIntegrationGroupingIT {

  @MavenTest
  void packaging_includes(MavenExecutionResult result) {
  }

  @Nested
  @MavenRepository
  class NestedExample {

    @MavenTest
    void basic(MavenExecutionResult result) {
    }

    @MavenTest
    void packaging_excludes(MavenExecutionResult result) {
    }

  }
}
----
That would result in having a common cache for the methods `basic` and `packaging_includes` within
the nested class `NestedExample`. The test method `packaging_includes` will have a cache on its own.
The directory tree looks like this:

[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── MavenIntegrationGroupingIT/
                   ├── packaging_includes/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── NestedExample/
                       ├── .m2/
                       ├── basic/
                       │   ├── project/
                       │   │   ├── src/
                       │   │   ├── target/
                       │   │   └── pom.xml
                       │   ├── mvn-stdout.log
                       │   ├── mvn-stderr.log
                       │   └── other logs
                       └── packaging_excludes/
                           ├── project/
                           │   ├── src/
                           │   ├── target/
                           │   └── pom.xml
                           ├── mvn-stdout.log
                           ├── mvn-stderr.log
                           └── other logs
----


=== Predefined Repository Content for Tests

There are existing test cases in which you need predefined dependencies, cause you can't rely
on existing dependencies in the central repository or anywhere else.
You have the option to define a repository either per testcase or per test class where you
can put existing dependencies for your test cases.
Those dependencies are behaving like you have installed them in your local repository via
`mvn install:install-file`.

In your test code the setup looks like the following. The important part is the definition
of the `@MavenPredefinedRepository` which indicates that the predefined repository in the appropriate
location needs to exist. This means that those dependencies from this directory are available for
each test case (`project_001` and `proeject_002`) in this test class.

[source,java]
.ProjectIT.java
----
@MavenJupiterExtension
@MavenPredefinedRepository
class ProjectIT {

  @MavenOption(MavenCLIOptions.DEBUG)
  @MavenTest
  void project_001(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }

  @MavenOption(MavenCLIOptions.DEBUG)
  @MavenTest
  void project_002(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }

}
----
In your test project definition you need to create the appropriate directory structure
including the needed contents, which looks like this:

[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── ProjectIT/
                        ├── .predefined-repo
                        │     ├── ...
                        │     └── ...
                        └── project_001/
                        │   ├── src/
                        │   └── pom.xml
                        └── project_002/
                            ├── src/
                            └── pom.xml
----
In the `.predefined-repo` you have to follow a usual maven repository structure. You can of course
define the `@MavenPredefinedRepository` also on the test method level, which would look like this:

[source,java]
.ProjectLevelIT.java
----
@MavenJupiterExtension
class ProjectIT {

  @MavenOption(MavenCLIOptions.DEBUG)
  @MavenTest
  @MavenPredefinedRepository
  void project_001(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }

  @MavenOption(MavenCLIOptions.DEBUG)
  @MavenTest
  @MavenPredefinedRepository
  void project_002(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }

}
----
The setup directories look like this:
[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── ProjectIT/
                        └── project_001/
                        │   ├── .predefined-repo
                        │   ├── src/
                        │   └── pom.xml
                        └── project_002/
                            ├── .predefined-repo
                            ├── src/
                            └── pom.xml
----

=== Single Project With Several Executions

Sometimes you need to execute a consecutive number of commands (usually maven executions) on the same
single project. This means having a single project and executing several maven execution
on that project in the end. Such a use case looks like this:

[source,java]
.SetIT.java
----
@MavenJupiterExtension
class SetIT
{
    private static final String VERSIONS_PLUGIN_SET =
      "${project.groupId}:${project.artifactId}:${project.version}:set";

    @Nested
    @MavenProject
    @TestMethodOrder( OrderAnnotation.class )
    @MavenOption(MavenCLIOptions.NON_RECURSIVE)
    @MavenGoal(VERSIONS_PLUGIN_SET)
    class set_001
    {

        @SystemProperty(value = "newVersion", content="2.0")
        @MavenTest
        @Order(10)
        void first( MavenExecutionResult result )
        {
            assertThat( result ).isSuccessful();
        }

        @SystemProperty(value = "newVersion", content="2.0")
        @SystemProperty(value = "groupId", content="*")
        @SystemProperty(value = "artifactId", content="*")
        @SystemProperty(value = "oldVersion", content="*")
        @MavenTest
        @Order(20)
        void second( MavenExecutionResult result)
        {
            assertThat( result ).isSuccessful();
        }
    }

}

----
The important part here is the `@MavenProject` annotation which marks the nested class as a container
which contains executions (`first` and `second`) with conditions on the same single project.
The `@MavenProject` defines that project name which is by default `maven_project`.
This means, you have to define the project you would like to test on like this:
[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── org/
                └── it/
                    └── SetIT/
                        └── set_001/
                            └── maven_project/
                                ├── src/
                                └── pom.xml
----

After test execution it looks like this:

[source,text]
----
.
└──target/
   └── maven-it/
       └── org/
           └── it/
               └── SetIT/
                   └── set_001/
                       └── maven_project/
                           ├── .m2/
                           ├── project/
                           │   ├── src/
                           │   ├── target/
                           │   └── pom.xml
                           ├── first-mvn-arguments.log
                           ├── first-mvn-stdout.log
                           ├── first-mvn-stderr.log
                           ├── second-mvn-arguments.log
                           ├── second-mvn-stdout.log
                           └── second-mvn-stderr.log
----
Each test case defined by the method name `first` and `second` has been executed on the same
project `maven_project`. Each execution has its own sets of log files which can be identified
by the prefix based on the method name like `first-mvn-arguments.log` etc.

The `@MavenProject` annotation can only be used on a nested class or on the test class itself
(where `MavenJupiterExtension` is located.). If you like to change the name of the project `maven_project` into
something different this can be achieved by using `@MavenProject("another_project_name")`.

<<<

== Test Case Execution


=== Conditionally Executing Tests

You might want to run an integration test only for a particular Maven version for example running
only for Maven 3.6.0? So how could you express this? The following code will show how you can do
that.

[source,java]
.ForthMavenIT.java
----
import static com.soebes.itf.extension.assertj.MavenCacheResultAssert.assertThat;
import static com.soebes.itf.jupiter.maven.MavenVersion.M3_0_5;
import static com.soebes.itf.jupiter.maven.MavenVersion.M3_6_0;

import com.soebes.itf.jupiter.extension.DisabledForMavenVersion;
import com.soebes.itf.jupiter.extension.EnabledForMavenVersion;
import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

@MavenJupiterExtension
class FirstMavenIT {

  @MavenTest
  @EnabledForMavenVersion(M3_6_0)
  void first_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isSuccessful();
  }

  @DisabledForMavenVersion(M3_0_5)
  @MavenTest
  void second_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isFailure();
  }

}
----

If you like to disable some tests on a particular Java version, this can be handled via
{junit-jupiter-user-guide-conditional-jre}[conditions like this].

//TODO: Make reference to JUnit Jupiter Manual
[source,java]
----
import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;
import static com.soebes.itf.jupiter.maven.MavenVersion.M3_0_5;
import static com.soebes.itf.jupiter.maven.MavenVersion.M3_6_0;

import com.soebes.itf.jupiter.extension.DisabledForMavenVersion;
import com.soebes.itf.jupiter.extension.EnabledForMavenVersion;
import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;
import org.junit.jupiter.api.condition.DisabledOnJre;
import org.junit.jupiter.api.condition.JRE;

@MavenJupiterExtension
@DisabledOnJre(JRE.JAVA_10)
class FirstMavenIT {

  @MavenTest
  @EnabledForMavenVersion(M3_6_0)
  void first_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isSuccessful();
  }

  @DisabledForMavenVersion(M3_0_5)
  @MavenTest
  void second_test_case(MavenExecutionResult execResult) {
    assertThat(execResult).isFailure();
  }
}
----

<<<

[#_assertions]
== Assertions

=== Overview
Let us take a look into a simple integration test. We would like to concentrate on the assertion part.
[source,java]
----
@MavenJupiterExtension
class FirstIT {
  @MavenTest
  void the_first_test_case(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }
}
----
After the test has run the resulting directory structure looks like this:
[source,text]
----
.
└──target/
   └── maven-its/
       └── org/
           └── it/
               └── FirstIT/
                   └── the_first_test_case/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── other logs
----
In each integration test you should let inject `MavenExecutionResult result` as a parameter of your
test case method, cause that gives you the opportunity to write assertion on the result of the maven
execution or what has been written into the resulting structure.

Let us start with two general assertions:

* `assertThat(result).isSuccessful();` The build was successful (return code of Maven run 0).
* `assertThat(result).isFailure();` The build has failed (return code of Maven run != 0).

Sometimes this is sufficient, but more often you have more complex scenarios to be checked.

Based on the directory structure in the result you can make assumptions about the
names which can be used in your assertions like the following:

//Check issue-25
* `assertThat(result).project()....` which will go into the `project` directory
* `assertThat(result).cache()...` will go into the `.m2/repository` directory.
// FIXME: https://github.com/khmarbaise/maven-it-extension/issues/26
// FIXME: * Reconsider how it should look like: result).log().stdout() or alike?
// FIXME: * `assertThat(result).stdout()..' will result into the access of the `mvn-stdout.log` file.
// FIXME: * `assertThat(result).stderr()..' will result into the access of the `mvn-stderr.log` file.

So next will be to check that a file in the `target` directory has been created during a test and
should contain the required contents. How should that be expressed? The following gives you an example
how you can achieve that:
[source,java]
----
assertThat( result ).isSuccessful()
  .project()
  .hasTarget()
    .withFile( "depDiffs.txt" )
      .hasContent( String.join( "\n",
          "The following differences were found:",
          "",
          "  none", "",
          "The following property differences were found:",
          "",
          "  none" ) );
----
The first part `.isSuccessful()` checks that the build has gone fine then we go into `project`
directory and via `withTarget()` we check the existence of the `target` directory as well as going
into that directory. Finally we append `withFile(...)`, which selects which file and redirects to
the `AbstractFileAssert<?>` of AssertJ which gives you the choice to check the contents of the file
as you like.

[source,java]
----
assertThat(project).hasTarget()
    .withEarFile()
    .containsOnlyOnce("META-INF/application.xml", "META-INF/appserver-application.xml");

----


=== Assertion for Maven Log

In integration tests is necessary to check the log output of a build. This is sometimes needed because
you want to check for particular output etc. which has been done by a plugin/extension etc.

In general there are currently two different outputs which can be reviewed:

* Console output (stdout)
* Error output (stderr)

These two parts are redirected into appropriate files within the integration result directory (see
`the_first_test_case`). In the following example you see two output files `mvn-stdout.log` and `mvn-stderr.log`.

[source,text]
----
.
└──target/
   └── maven-its/
       └── org/
           └── it/
               └── FirstIT/
                   └── the_first_test_case/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── other logs
----

Let us take a look into an example test case like this:

[source,java]
.LogoutputIT.java
----
package com.its;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenCLIOptions;

@MavenJupiterExtension
class LogoutputIT {

  @MavenTest
  void basic(MavenExecutionResult result) {
    assertThat(result)
      .out()
      .warn()
      .containsExactly("Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!");
  }
}
----

Usually you will be using the injection of the `MavenExecutionResult` in your test case. This
gives you the option to enhance the assertions like the following:

* `assertThat(result).out()....`
* `assertThat(result).err()....`

The first one `assertThat(result).out()....` will give you access to the `stdout` of the build (which means `mvn-stdout.log`)
whereas the second one give you access to the `stderr` of the build (means `mvn-stderr.log`).

In using the `..out()` it can be combined with things like:

* `.info()`
* `.warn()`
* `.debug()`
* `.error()`

Those parts will remove the appropriate prefix from each output line `[INFO]`, `[WARNING]`, `[DEBUG]` or `[ERROR]`
(This includes the single space which is followed by them).
From that point on you can use the usual AssertJ assertions as in the given example above `containsExactly`
which implies that only a single would be allowed to have that single warning.

Furthermore if you like to get the plain log output that can be achieved by using:

* `.plain()`

That will not filter anything.

Another example of using the assertions could look like this:

include::{itfexample}/itf-examples/src/test/java/com/soebes/itf/examples/LogoutputIT.java[tag=stdout]

This will extract all messages with the prefix `[INFO] ` of the log and check if there is
at least one line which contains the given content.

We can check for warnings like the following:

include::{itfexample}/itf-examples/src/test/java/com/soebes/itf/examples/LogoutputIT.java[tag=warning]

You can access directly the `stdout` and/or the `stderr` of the Maven build and do things yourself
if you prefer to go that way. In this case you have to add another injection to the test case
(`MavenLog mavenLog` or like this `result.getMavenLog().getStdout()`).

include::{itfexample}/itf-examples/src/test/java/com/soebes/itf/examples/LogoutputIT.java[tag=selfmade]

The `stderr` output can be accessed as well like this:

include::{itfexample}/itf-examples/src/test/java/com/soebes/itf/examples/LogoutputIT.java[tag=error]

A full fledged example can be found `itf-examples/src/test/java/com/soebes/itf/examples/LogoutputIT.java`
within the itf project.

=== Expressing Assertions


[source,java]
.CompareDependenciesIT.java
----
package org.codehaus.mojo.versions.it;

import com.soebes.itf.jupiter.extension.MavenJupiterExtension;
import com.soebes.itf.jupiter.extension.MavenTest;
import com.soebes.itf.jupiter.maven.MavenExecutionResult;

import static com.soebes.itf.extension.assertj.MavenITAssertions.assertThat;

@MavenJupiterExtension
class CompareDependenciesIT
{
    @MavenGoal("${project.groupId}:${project.artifactId}:${project.version}:compare-dependencies")
    @SystemProperty(value = "remotePom", content="localhost:dummy-bom-pom:1.0")
    @SystemProperty(value = "reportOutputFile", content="target/depDiffs.txt")
    @MavenTest
    void it_compare_dependencies_001( MavenExecutionResult result )
    {
        assertThat( result ).isSuccessful()
          .project()
          .hasTarget()
          .withFile( "depDiffs.txt" )
          .hasContent( String.join( "\n",
            "The following differences were found:",
            "",
            "  none",
            "",
            "The following property differences were found:",
            "",
            "  none" ) );
    }
}
----

[#_debugging]
== Debugging Plugins

:intellij-junit: https://www.jetbrains.com/help/idea/run-debug-configuration-junit.html#configTab
:intellij-remote: https://www.jetbrains.com/help/idea/tutorial-remote-debug.html#335b9aea

=== Overview

Sometimes you need to debug your code of your implemented plugin because
usual tests or even integration tests are not enough. The question is
how?

Generally you have to define the system property `ITF_DEBUG=true` before you
run your integration test. This will start the integration test while executing `mvnDebug`
instead of `mvn` and will simply wait for a connection of a remote debugger usually
from your IDE.

=== Limitations

Debugging can only being done after you have run your whole integration tests once via
command line. An idea for the future might be a plugin for IDE's to support that in a
more convenient way (Help is appreciated).

==== IDEA IntelliJ

You have to define a {intellij-junit}[system property for debugging in your IDE run configuration].
In the configuration you will find an entry for the VM which usually contains already `-ea` and
exactly that field needs to be enhanced with the entry `-DITF_DEBUG=true`. By using this run
configuration you can start the integration test just as before from within your IDE. The process
will wait until you are connected.

The next step is to {intellij-remote}[configure remote debugging] which means to define the port `8000`
as port and check if you are using JDK8 or JDK9+ in your configuration.

I recommend to start only a single integration test case via the above described run configuration,
in debugging mode otherwise all processes woulduse the same port which would result in failure
because only one can use that port.

==== Eclipse

Basically it should work the same.

(Feedback is welcome to give more details on that.)

==== Netbeans

Basically it should work the same.

(Feedback is welcome to give more details on that.)


<<<

== Special Cases

=== Overview

In some situations it is needed to fail a build of a plugin/extension for testing purposes or other things
which not that usual. This chapter describes such situations and shows solutions for those.

=== Failing the build

The integration testing framework contains a plugin `itf-failure-plugin` which (implied by the name) it's only
purpose is to fail a build. The following shows a configuration which will produce a `[WARNING]` during
the build cause the plugin needs to be configured.

[source,xml]
----
include::{itfexample}/itf-failure-plugin/src/test/resources-its/com/soebes/itf/maven/plugin/failure/FailureIT/basic_configuration/pom.xml[tag=configuration]
----

The plugin does not bind to any life cycle phase by default which is intentionally to require a binding
to a phase you like. This means also you can bind that plugin to any phase you would like to. In the previous
example it is bound to `initialize`.

The following example shows a real example how the plugin has been configured correctly (only the `configuration` area).
The configuration will fail the build with a `MojoExecutionException` (exeuctionException=true) and a text of the
exception can given via `exception` configuration part.

[source,xml]
----
include::{itfexample}/itf-failure-plugin/src/test/resources-its/com/soebes/itf/maven/plugin/failure/FailureIT/fail_with_mojo_execution_exception/pom.xml[tag=configuration]
----

The final example will fail the build with a `MojoFailureException` (failureException=true) and the text of the exception
can given via `exception` configuration part as before.

[source,xml]
----
include::{itfexample}/itf-failure-plugin/src/test/resources-its/com/soebes/itf/maven/plugin/failure/FailureIT/fail_with_mojo_failure_exception/pom.xml[tag=configuration]
----


=== Project Not at Root Level
Sometimes you have a structure in your version control repository which does not
fit with the assumptions which are made by the integration testing framework.
As an example we will take a look onto the following example:
[source,text]
----
.
└──root/
   └── supplemental/
        └── files
   └── subdirectory
        ├── src/
        └── pom.xml
----

The `root` is the location where you check out your source.
The directory `supplemental` contains other files and/or subdirectories which are not needed for testing. The
`subdirectory` contains the directory with the plugin you would like to test with the framework.A usual setup described
in previous chapters will not work.

The following integration test shows what you need to do to set up that kind of
project layout correctly. The important part is `@MavenProjectLocation` which defines the directory where to find the
`pom.xml`. In our case this is the `subdirectory` (previous layout example).

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
class TheIT {

  @MavenTest
  @MavenProjectLocation("subdirectory")
  void basic(MavenExecutionResult result) {
    ...
  }
}
----

The definition can be done on method level or on class level. That
is useful if you have several test cases where the `pom.xml`is being found in a subdirectory instead of being at the
root level.

You can define the `@MavenProjectLocation` on the class level to define the same setup for several tests.
The test cases `first` and `second` will use that. The configuration for `third` test case is using a different
location as expressed with the supplemental `@MavenProjectLocation`. This is very unlikely.

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
@MavenProjectLocation("subdirectory")
class TheIT {

  @MavenTest
  void first(MavenExecutionResult result) {
    ...
  }
  @MavenTest
  void second(MavenExecutionResult result) {
    ...
  }
  @MavenTest
  @MavenProjectLocation("differentsubdir")
  void third(MavenExecutionResult result) {
    ...
  }
}
----

=== Different Project Sources

Sometimes it is necessary to do the testing of your plugin
in a different way than usually. For example, you would like to
make the testing project setup programmatically or in other ways.

It might also happen that you want to reuse the same project
setup for a number of different integration tests.

The default setup assumes that your projects which are used for the
integration tests are located under `src/test/resources-its`.
Those projects will be copied during the setup into the
`target/maven-its` directory to execute the tests.

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
class TheIT {

  @MavenTest
  void basic(MavenExecutionResult result) {
    ...
  }
}
----

==== Generated Project Setup
If you like to generate your project setup programmatically you can turn of
the need of having to provide an appropriate project setup in  `resources-its/.../`.

This can be achieved by defining `@MavenProjectSources(resourcesUsage=NONE)`
that means in consequence you have to provide a full project setup on your own.
The location where you have to create the setup can be calculated by using the parameters
which are injected into the `beforeEach` method (see `MavenProjectResult`).

The location (directory) can be used within your `beforeEach` method
`result.getTargetProjectDirectory()`.

There is a simple example for such setup in `MavenProjectSourcesBasicIT` for
more details.

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
@MavenProjectSources(resourcesUsage=NONE)
class TheIT {

  @BeforeEach
  void beforeEach(TestInfo testInfo, MavenProjectResult result) {
    //Setup a project into the appropriate location
    // on your own
  }
  @MavenTest
  void basic(MavenExecutionResult result) {
    ...
  }
}
----


==== Reusing Project for Several Tests

It could be useful to define a single project setup which should reused for
several executions of integration tests.

In contradiction the `@MavenProject` gives the option to execute more than
one integration test on the same project.

The `@MavenProjectSource(source="com/soebes/source-project")`
defines the location where to find the project setup for the integration test
relative to the `src/test/resources-its` directory. This location will
not change based on package of the integration test class, method or alike.

Reconsider the default setup first:

[source,java]
.TheDefaultIT.java
----
package com.its;

@MavenJupiterExtension
class TheIT {

  @MavenTest
  void basic(MavenExecutionResult result) {
    ...
  }
}
----
Based on the given setup the used integration project has to be located
in the following directory:

[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── com/
                └── its/
                    └── TheIT/
                          └── basic/
                               ├── src/
                               └── pom.xml
----

If you define the integration test like this:

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
@MavenProjectSources(source="com/soebes/source-project")
class TheIT {

  @MavenTest
  void basic(MavenExecutionResult result) {
    ...
  }
}
----
This means having the provided test project is now located
in the `source-project` directory instead:

[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── com/
                └── soebes/
                    └── source-project/
                             ├── src/
                             └── pom.xml
----

So you can reuse the same project for more than one integration test simply
by creating a second integration test like this:

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
@MavenProjectSources(source="com/soebes/source-project")
class TheIT {

  @MavenTest
  void basic_one(MavenExecutionResult result) {
    ...
  }

  @MavenTest
  void basic_two(MavenExecutionResult result) {
    ...
  }
}
----

This setup means to reuse the same project setup for both test cases
`basice_one` and for `basic_two`.

The most important part will be visible in the `target/` directory:

[source,text]
----
.
└──target/
   └── maven-its/
       └── com/
           └── its/
               └── TheIT/
                   ├── basic_one/
                   │   ├── .m2/
                   │   ├── project/
                   │   │   ├── src/
                   │   │   ├── target/
                   │   │   └── pom.xml
                   │   ├── mvn-stdout.log
                   │   ├── mvn-stderr.log
                   │   └── other logs
                   └── basic_two/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── other logs
----
The directory `project` of both cases `basic_one` and `basic_two`
will contain a copy of the same setup `source-project`.


==== Different Setup for Every Method

You can define also different project setups for each
integration test case individual if you like.

The following example uses the same location for the
tests `one` and `two`.

The test methods `three` and `four` uses a different
source location.

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
class TheIT {

  @MavenTest
  @MavenProjectSources(source="com/soebes/base1")
  void one(MavenExecutionResult result) {
    ...
  }
  @MavenTest
  @MavenProjectSources(source="com/soebes/base1")
  void two(MavenExecutionResult result) {
    ...
  }
  @MavenTest
  @MavenProjectSources(source="com/soebes/base2")
  void three(MavenExecutionResult result) {
    ...
  }
  @MavenTest
  @MavenProjectSources(source="com/soebes/base2")
  void four(MavenExecutionResult result) {
    ...
  }
}
----

It is also possible to define the project source location
on a nested class level. This would simply the previous example
a bit.

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
class TheIT {

  @MavenTest
  @MavenProjectSources(source="com/soebes/base1")
  void one(MavenExecutionResult result) {
    ...
  }
  @MavenTest
  @MavenProjectSources(source="com/soebes/base1")
  void two(MavenExecutionResult result) {
    ...
  }

  @Nested
  @MavenProjectSources(source="com/soebes/base-nested")
  class NestedSetup {
    @MavenTest
    void three(MavenExecutionResult result) {
      ...
    }
    @MavenTest
    void four(MavenExecutionResult result) {
      ...
    }
  }

}
----

==== Overwrite Location

It's also possible to define a kind of global source location for
all methods within the class and overwrite that either by defining
it on a nested class level or on test method level.

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
@MavenProjectSources(source="com/soebes/base1")
class TheIT {

  @MavenTest
  void one(MavenExecutionResult result) {
    ...
  }
  @MavenTest
  void two(MavenExecutionResult result) {
    ...
  }

  @Nested
  @MavenProjectSources(source="com/soebes/base-nested")
  class NestedSetup {
    @MavenTest
    void three(MavenExecutionResult result) {
      ...
    }
    @MavenTest
    void four(MavenExecutionResult result) {
      ...
    }
  }

}
----

=== Different settings.xml

==== Using settings.xml

If you need to change the `settings.xml` in some ways it might be necessary
to provide a special `settings.xml` within your integration tests.
This can be achieved by annotating the appropriate integration test with
`@MavenSettingsSource` to signal that a particular `settings.xml` will be
loaded during the integration test.

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
@MavenSettingsSource
class TheIT {

  @MavenTest
  void basic_one(MavenExecutionResult result) {
    ...
  }

  @MavenTest
  void basic_two(MavenExecutionResult result) {
    ...
  }
}
----

By just adding `@MavenSettingsSource` you have to provide
an appropriate `settings.xml` in the `resources-its` location
based on package of your integration test, class, method name
maybe based on your nested classes etc. in the same way as the
appropriate project has to be provided.

[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── com/
                └── its/
                    └── TheIT/
                          ├── basic_one/
                          │    ├── src/
                          │    ├── pom.xml
                          │    └── settings.xml
                          └── basic_two/
                               ├── src/
                               ├── pom.xml
                               └── settings.xml
----
The usage of the annotation on the class level means to require
a `settings.xml` for each integration test with the class/nested
class etc.

It's easy to limit the need for a particular `settings.xml` by
using the annotation `@MavenSettingsSource` on a method level instead.

==== Different location

If you don't like to provide a `settings.xml` for each integration test
project separately it is easy to provide only a single `settings.xml`
from a particular location.  This can be achieved by defining the annotation
using the source attribute of the `@MavenSettingsSource` annotation like this:
`@MavenSettingsSource(source="com/soebes/source-project")`.

[source,java]
.TheIT.java
----
package com.its;

@MavenJupiterExtension
@MavenSettingsSource(source="com/soebes/source-project")
class TheIT {

  @MavenTest
  void basic_one(MavenExecutionResult result) {
    ...
  }

  @MavenTest
  void basic_two(MavenExecutionResult result) {
    ...
  }
}
----

By using the previous definition of the integration
test in the `resources-its` directory looks like the following:

[source,text]
----
.
└── src/
    └── test/
        └── resources-its/
            └── com/
                ├── soebes/
                │   └── source-project/
                │          └── settings.xml
                └── its/
                    └── TheIT/
                          ├── basic_one/
                          │    ├── src/
                          │    └── pom.xml
                          └── basic_two/
                               ├── src/
                               └── pom.xml
----

That means the defined `settings.xml` (`source-project` directory ) will be
used for both executions `basic_one` and `basic_two``

==== Generate programmatically

In some situations it might be necessary to generate the `settings.xml`
programmatically instead of providing a handwritten one.
This can be achieved by using the `@MavenSettingsSource` annotation enhanced
with `@MavenSettingsSource(resourcesUsage = NONE)`
There is an example in the examples part of the project `MavenSettingsSourceBasicIT`
where you can take a deeper look as an inspiration.

[appendix]
== MavenExecutionResult
In some situations you need access to the directories which have been created during
the integration tests. That can simply being achieved by using the injection of
`MavenExecutionResult` or `MavenProjectResult` depending on your needs.
[source,java]
----
@MavenJupiterExtension
class FirstIT {
  @MavenTest
  void the_first_test_case(MavenExecutionResult result) {
    assertThat(result).isSuccessful();
  }
}
----
the resulting directory structure looks like this:
[source,text]
----
.
└──target/
   └── maven-its/
       └── org/
           └── it/
               └── FirstIT/
                   └── the_first_test_case/
                       ├── .m2/
                       ├── project/
                       │   ├── src/
                       │   ├── target/
                       │   └── pom.xml
                       ├── mvn-stdout.log
                       ├── mvn-stderr.log
                       └── other logs
----

There are existing the following information which you can use for further check etc.
You can access them via:

* `result.getMavenProjectResult().getTargetBaseDirectory();`
   This represents the directory `the_first_test_case` in the above directory
   structure.
* `result.getMavenProjectResult().getTargetProjectDirectory()`
   This represents the directory `project` in the above directory structure.
* `result.getMavenProjectResult().getCacheDirectory()`
   This represents the directory `.m2` in the above directory structure.

If you only need access to the directory structure and not to the result of the build
or the logging output of the Maven build you can change your integration test like this:

[source,java]
----
@MavenJupiterExtension
class FirstIT {
  @MavenTest
  void the_first_test_case(MavenProjectResult result) {
    ...
  }
}
----


